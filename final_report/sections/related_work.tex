\documentclass[fina_report_innit.tex]{subfiles}

\begin{document}

\section{Related Work}


\subsection*{Feature-driven Development and One Track}
In Xiaocheng et al.'s \"Agile Development of Secure Web Applications\" [adoswa] feature-driven development is introduced as a part of the process. Xiaocheng et al. specifically discuss agile development in the context of secure systems (defined as \"a system that is protected against specific undesired outcomes\") [adoswa] which is an attribute shared with Ericsson's system. Hribar et al. [ftriauotasld] have presented an overview of Ericsson's approach to One Track development which mainly is based on internal Ericsson documentation. Hribar et al. [ftriauotasld] introduce a set of main principles for One Track that are related to continuous integration and agile, and the focus is mainly set on how to successfully implement and develop according to the One Track development strategy. Although a large part of Ericsson's software is developed through MDSD, Hribar et al. do not identify any differences in how well One Track works in combination with MDSD compared to non-MDSD. Even though MDSD is common in the domain of telecommunications, the characteristics of a MDSD environment are not mentioned as important factors to consider in the litterature related to One Track and feature-driven development. 

\subsection*{Component Testing}
Unit testing is not an exclusive practice of any development style, but can be an important part of software development. While not limited to model-driven development, the trend of modelling software provides developers and testers with an excellent opportunity to lean on test generation technology to automatically generate conformance tests from UML diagrams [ASOMDTT], [UBTGE].  

[ASPATTT] claims traditional unit testing as tedious and cumbersome process as every methods needs to be tested and changes to code may require changes to each test. The test code itself needs to be examined, and one could argue that test code is as likely to be faulty as the code it is testing. As a solution to these obstacles [AUTHORS] propose to automate unit tests where possible by using a framework such as JUnit, which encourages a closer integration of testing. Even with testing frameworks however,  unit testing is often a time consuming task that require test cases to be manually coded and maintained when the code under test changes. This could discourage testing as a parallel task to coding [ASPATTT]. 

Model Driven Development offers another take on unit testing; [ASOMDTT] states that the use of UML has led many researchers to use state machine diagrams and sequence diagrams to generate tests, including unit tests. The advantage of model based testing is that it can easily be automated and shifted to earlier stages of the development process. Model based test generation allow generation of tests that are independent of other components of the system, aiding the process of unit testing [AGTCUMDA].

Several approaches to model driven unit testing rely on UML sequence diagrams to generate unit tests, in [UBTGE] [authors] states that it may require a lot of these diagrams to represent a complex component and its interaction with its client or clients. Whilst each component may behave correctly during unit tests, when interacting with other components this may not be the case. [Authors] approach also depend on UML sequence diagrams, but also incorporate UML state chart diagrams. Their formulation of state chart diagrams include modelling the interactions between components and result in a representation of behavior of all components included. The advantage of this model is that test cases generated can perform both unit and integration testing [UBTGE].

A hypothesis we would like to explore is how MDD has altered the ways of testing at Ericsson; if they have employed any particular testing practices as a result of the opportunities MDD can offer regarding unit testing, and their experienced results of said implementation. 

\subsection*{Component Testing}
[small intro into testing stuff – not sure if i'll be doing the introduction or not!]

While not a concrete practice of MDD, component testing can be an important part of software development, especially when it comes to large and complex systems which are comprised of many components.

[componenttestability 1] authors describe problems with standard component testing. They state that making the tests reusable is the greatest challenge when using this type of testing. If the tests are created as part of a framework, they end up becoming dependent upon that framework. As an alternative, the author suggests using a technique referred to as Built-In-Tests (BIT). BIT is an alternative to using a framework as involves the use of writing tests into the classes, modules and components themselves. It tends to be cheaper and faster to develop while not requiring an external suite or framework to run; the tests are instead accessed with an interface into the appropriate component.

Model driven testing techniques commonly involve the use of a modelling language, test generation, a target and tool support [componenttesting:3]. Yuan et al. describe a method of Model Driven Component Testing (MDCT) which combines The UML Testing Profile (UTP) [componenttesting:3:1] and the Testing and Test Control Notation Version 3. These concepts are then used to define a framework from which automatic test cases can be derived and then the Model-Driven Architecture (MDA) approach is applied [componenttesting:3:2]. 

During 2004-2006, AUTHORS performed research in conjunction with Ericsson to help investigate faults or Trouble Reports (TRs) and their frequencies in a large, complex system. They found that designers at component testing levels do not find faults related to unclear specifications. These faults made up \%46.6 of all software faults discovered in that specific case study. These types of faults are therefore discovered later in the testing process. The key reason they give is that it is very hard for a developer to design, implement and specify code given the complexity of the environment and the knowledge of the context which is required. 

They found that during the year 2005, where there was a strong influence on component testing, quality drastically improved in the software, especially in terms of faults. The authors ultimately came to the conclusion that unit and component testing have next to no chance of finding a majority of faults which stem from a lack of knowledge and context. They further concluded that component testing is limited in very complex systems and it highlights the need for higher level integration and systems testing along side component testing.

Given this and the other previous work, a simple hypothesis we would like to explore is whether or not the adoption of MDD by Ericsson has lead to a hindrance or an improvement when it comes to testing using component testing methods.

\subsection*{Impact of Agile Development on MDSD}

Agile Development (AD) and MDSD both address the issues of high change rates, time-to-market, increased return on investment (ROI) and high quality software [coasd]. However, the solutions that are proposed by AD differ to those proposed by MDSD [coasd]. Since AD has been developed to suit the object-oriented paradigm, Stojanovic, Dahanayake and Sol support that the higher level of abstraction that can be achieved through MDSD can highly support agile principles [coasd]. They discuss the separation of concerns that can be achieved with the use of components [coasd], a point that is also raised by Diarmuid Corcoran, who talks about MDSD experiences at Ericsson [mfa]. He states that two major complexities exist within the large-scale organization that is Ericsson; firstly, the complexity with regard to the number of people involved in a project, and secondly the domain complexity [mfa]. Corcoran states that by incorporating a modeling based development paradigm, the problems arising from these complexities are solved. 

Furthermore, MDSD and Agile Development both focus on the development of software that can be understood and validated by the involved stakeholders and end users [mdsden]. . Stahl and Völter identify that MDSD does not contradict the agile principle of individuals and interactions over processes and tools [mdsden]. An MDSD team is encouraged to establish their development process without the constraint of a document-centric approach [mdsden]. Additionally, diagrams are considered the central artifact in MDSD, functioning both as working software and comprehensive documentation [mdsden]. This inherent property of MDSD satisfies the agile principles of working software over comprehensive documentation as well as customer collaboration over contract negotiation, since the model diagrams function as the means for communication with the customer [mdsden]. To support the argument that MDSD can help to scale agile practices, Stahl and Völter suggest that the agile principle of response to change over following a plan is facilitated with MDSD by the automatic implementation of a change in multiple parts of a system [mdsden].

Stahl and Völter suggest that as long the MDSD rules are observed, any agile practice may be used to support the micro-activities of the development process [mdsden]. This is exemplified by Zhang and Patel, who discuss MDSD and agile practices at Motorola [amddip]. They identify corresponding and related agile and MDSD practices, and present an approach to bridging the gap between to some of the practices that are the focus of our research, in particular Continuous Integration and Unit Testing. With respect to Continuous Integration, or Continuous Modeling in the MDSD domain, Zhang and Patel identify a UML problem when merging changes simultaneously [amddip]. This has been solved by utilizing an integration branch and coordinating the developers to push a few changes frequently. With respect to Unit Testing, they propose bridging white-box (model verifier) and black-box (test harness) testing in order to be able to not only test UML elements but also external operations [amddip]. Zhang and Patel further claim that this technique may be adapted to execute integration and system testing [amddip].


\end{document}